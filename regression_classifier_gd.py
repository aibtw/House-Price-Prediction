import sys
import numpy as np
from numpy import random as rnd
from matplotlib import pyplot as plt


def train(n):
    """
    A function that trains a model to predict house prices based on provided train data (train.csv).
    Only certain feature are used, which are in columns 1, 4, 17, 18, 19, 43, 44, 46, 62, 77 (count starts at 0)

    :param n: polynomial order, where 1 means linear, 2 means 2nd order, 3 means 3rd order.
    """
    # ----------------- default output files ----------------- #
    output_file = "Linear_Train_Results.txt"
    output_thetas = "linear_thetas"
    # ---------------------- Read input ---------------------- #
    x = np.transpose(np.loadtxt("train.csv", delimiter=',', skiprows=1, usecols=(1, 4, 17, 18, 19, 43, 44, 46, 62, 77)))
    y = np.loadtxt("train.csv", delimiter=',', skiprows=1, usecols=-1)
    # ------------------- Feature Scaling -------------------- #
    s_factor = np.amax(x, axis=1)
    x = x / s_factor[:, None]
    # --------------------- Learning rate -------------------- #
    lr = 0.001
    # -------------------- Initialize loss ------------------- #
    loss = list()
    num_of_examples = x.shape[1]
    # --------- Manipulate input data for processing --------- #
    """ 
        trainX = [1 , 1,  1  ... ] <--- To be multiplied by Theta0
                 [x1, x2, x3 ... ] <--- Feature 1, multiplies by Theta1
                 [v1, v2, v3 ... ] <--- Feature 2, multiplied by Theta2
                 ... etc
                 
        trainY = [Y1, Y2, Y3 ... ]
    """
    trainY = y
    trainX = np.vstack([np.ones(num_of_examples), x])

    # Based on input, choose whether to go with linear model (power 1), power2, or power3.
    if n == 1:    # linear (power 1)
        pass
    elif n == 2:  # power 2
        trainX = np.vstack([trainX, np.square(x)])
        output_file = "Polynomial_order2_Train_Results.txt"
        output_thetas = "Polynomial_order2_thetas"
    elif n == 3:  # power 3
        trainX = np.vstack([trainX, np.square(x), np.power(x, 3)])
        output_file = "Polynomial_order3_Train_Results.txt"
        output_thetas = "Polynomial_order3_thetas"
    num_of_features = trainX.shape[0]

    # ------------ Thetas random start point ------------ #
    thetas = rnd.random(num_of_features)

    # -------------------- Main Loop -------------------- #
    for i in range(300000):
        """ hypothesis hyp = [h1 , h2,  h3  ... ]. (This is the guess generated by current value of theta)"""
        hyp = np.dot(thetas, trainX)

        """ Update theta"""
        grad = np.dot(trainX, np.vstack(hyp - trainY) / num_of_examples)
        thetas = thetas - (lr * np.hstack(grad))

        """Calculate loss"""
        loss.append(float(np.sum((hyp - trainY) ** 2) / num_of_examples))
        relative_loss = abs((loss[i] - loss[i - 1]) / loss[i] * 100)
        if relative_loss <= 0.001 and i != 0:
            print("Stopped at iteration: " + str(i))
            break

    # --------------------- output area ---------------------- #
    print("loss is: " + str(loss[-1]))
    np.save(output_thetas, thetas)  # Save thetas for the test phase.
    with open(output_file, 'w') as wr:
        wr.write("The loss value for train model is: \n" + str(loss[-1]))
        wr.write("\nThe Theta values for training model are: \n")
        wr.write(np.array2string(thetas))
    plt.plot(loss)
    plt.show()


def test():
    """
    A function that test a model that predicts house prices, based on provided test data set (test.csv)
    :return:
    """
    # ----------------- Reading General Input ---------------- #
    x = np.transpose(np.genfromtxt("test.csv", delimiter=',', skip_header=1,
                                   usecols=(1, 4, 17, 18, 19, 43, 44, 46, 62, 77),  # use only the specified columns
                                   filling_values=0))
    y = np.loadtxt("test.csv", delimiter=',', skiprows=1, usecols=-1)
    # ------------------- Feature Scaling -------------------- #
    s_factor = np.amax(x, axis=1)
    x = x / s_factor[:, None]
    (x_m, x_n) = x.shape

    print("\n\n#==================== X and Y ====================#")
    print(x)
    print(y)

    losses = {"Linear": 0, "Polynomial of order2": 0, "Polynomial of order3": 0}
    # ---------------------- Linear Test ---------------------- #
    print("\n\n#==================== Linear Testing ====================#")
    train_thetas = np.load("linear_thetas.npy")

    testX = np.vstack([np.ones(x_n), x])
    testY = y
    hyp = np.dot(train_thetas, testX)
    print("Hypothesis Overview:")
    print(hyp)
    test_loss = np.sum((hyp - testY) ** 2) / x_n
    losses["Linear"] = test_loss
    print("Linear Test Loss is: " + str(test_loss))
    # ------------------- Test Linear Done ------------------- #

    # -------------------- 2nd order Test ------------------- #
    print("\n\n#==================== 2nd order Testing ====================#")
    # -------------------- Reading input --------------------- #
    train_thetas = np.load("Polynomial_order2_thetas.npy")
    # ------------------- update variables ------------------- #
    testX = np.vstack([testX, np.square(x)])
    hyp = np.dot(train_thetas, testX)
    print("Hypothesis Overview:")
    print(hyp)
    test_loss = np.sum((hyp - testY) ** 2) / x_n
    losses["Polynomial of order2"] = test_loss
    print("Polynomial 2nd order Test Loss is: " + str(test_loss))
    # ----------------- 2nd order Test Done ----------------- #

    # -------------------- 3rd order Test ------------------- #
    print("\n\n#==================== 3rd order Testing ====================#")
    # -------------------- Reading input --------------------- #
    train_thetas = np.load("Polynomial_order3_thetas.npy")
    # ------------------- update variables ------------------- #
    testX = np.vstack([testX, np.power(x, 3)])
    hyp = np.dot(train_thetas, testX)
    print("Hypothesis Overview:")
    print(hyp)
    test_loss = np.sum((hyp - testY) ** 2) / x_n
    losses["Polynomial of order3"] = test_loss
    print("Polynomial 3rd order Loss is: " + str(test_loss))
    # ----------------- 3rd order Test Done ----------------- #

    # Show which model was the best
    best_loss = min(zip(losses.values(), losses.keys()))[1]
    print("\n----------------------------------------------------------------------------------------"
          "\nThe best model in terms of loss is: {model} model, "
          "with loss equal to {loss}"
          "\n----------------------------------------------------------------------------------------"
          "\n\n".format(model=best_loss, loss=losses[best_loss]))


if __name__ == "__main__":
    if len(sys.argv) == 1:
        print("not enough arguments.\n"
              "Use the following arguments in command line:\n"
              "\tT1: Train a linear model\n"
              "\tT2: Train a polynomial model of order 2\n"
              "\tT3: Train a polynomial model of order 3\n"
              "\tV: validate(test) the trained models")
        exit()

    if sys.argv[1].upper() == "T1":
        train(1)
    elif sys.argv[1].upper() == "T2":
        train(2)
    elif sys.argv[1].upper() == "T3":
        train(3)
    elif sys.argv[1].upper() == "V":
        test()
    else:
        print("wrong command line argument.")
        exit()
